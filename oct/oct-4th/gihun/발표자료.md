# 렉시컬 스코프와  클로저

책에 있는 예제 코드를 가져왔습니다

```
const x =1

function foo() {
    const x= 10
    bar()
}

function bar() {
    console.log(x)
}

foo()       // 1
bar()       // 1
```

전역 스코프에 x=1 이 존재하기 떄문입니다.

bar 함수는 "정의될때의 스코프 전역 스코프"를 기억합니다.
```
function bar() {
    console.log(x)  // console.log(1)
}
```
```
foo()
```

+ foo 내부에 const x = 10 있어도 bar 는 여전히 전역 스코프를 참조합니다

+ bar 함수는 foo 함수 내부에서 선언이 된것이 아니라 전역에서 정의된 함수이기 떄문입니다.

```
function foo() {    // function foo() {
    const x= 10     //      const x = 10
    bar()           //      console.log(1)
}                   //}
```


### 핵심 개념

이 예제를 통해서 얻을 수 있는 렉시컬 스코프의 핵심 개념은 

-> "그 함수가 어디서 정의되었는가" 에 의해 결정된다는것입니다
   
    (함수 내부에서 정의되었는지,전역인지 등등)

만약 10 이 출력 되게 하려면??

bar 함수를 foo 내부에서 정의하면 되겠죵?

```
const x =1

function foo() {
    const x= 10
        function bar() {
            console.log(x)
    }
    bar()
}

foo()  // 10


```

# 클로저 

```
function makeCounter() {
  let count = 0; // makeCounter의 지역변수

  return increase () {
    count++;
    console.log(count);
  };
}

const counter1 = makeCounter();
counter1(); // 1
counter1(); // 2
```

1. makeCounter() 실행시 count 가 0 으로 만들어집니다
2. makeCounter() 함수는  increase() 함수를 return 하면서 종료됩니다
3. makeCounter 함수의 실행이 종료되면, 일반적으로 지역 변수 count는 가비지 컬렉션 대상이 되어 메모리에서 사라져야 합니다.

4. 하지만 makeCounter가 반환한 내부 함수(increase, 즉 counter1)는 자신의 **외부 렉시컬 환경(makeCounter 스코프)**에 있는 변수 count를 참조하고 있습니다.

5. 결과적으로, count 변수는 makeCounter 함수가 종료되었음에도 불구하고, counter1 함수가 살아있는 한 메모리에서 가비지 컬렉션되지 않고 계속 유지됩니다.

6. 변수 counter1에 makeCounter() 함수를 참조할 수 있도록 작성 했습니다

7. increase 함수 동작부분에 count++ 1씩 증가시키는 동작을 넣고 출력하게끔 작성을 했기 떄문에 

8. 클로저 덕분에, 참조되는 지역 변수는 함수가 종료된 후에도 마치 "붙잡혀 있는" 것처럼 메모리에 남아 클로저의 생명 주기와 함께 유지됩니다.

```
counter1(); // 1
counter1(); // 2
```

+ 함수를 여러번 호출하면 1씩 증가되는걸 확인 할 수 있습니다 

## 핵심개념

클로저는 함수가 자신이 정의될 당시의 스코프(환경)을 기억하고 그 스코프 밖에서 실행 되더라도 스코프 내의 변수들에 접근할 수 있는 기능

책을 읽으면서 엥?? 했던 부분을 가져와서 정리했습니다.

함수가 정의된 위치가

전역인지 함수 내부인지를 파악하고 개발을 하는것이 

추후에 생길 오류나 유지보수 면에서 

큰 영향이 있을것이란 생각이 들었습니다  