# 9장 타입 변환과 단축 평가

<br />

# 9.1 타입 변환이란 ?
자바스크립트의 모든 값에는 타입 존재

### 명시적 타입 변환 (explict coercion) / 타입 캐스팅 (type casting)
: 개발자가 의도적으로 타입을 변환하는 것

### 암묵적 타입 변환 (implict coercion) / 타입 강제 변환 (type coercion)
: 개발자의 의도와 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것

<br />

명시적 타입 변환이나 암묵적 타입 변환이 기존 원시 값을 직접 변경하는 것은 아님 ❌

원시 값은 변경 불가능한 값 (immutable value)이므로 변경 불가 ❌

<br />

### 타입 변환이란
기존 원시 값을 사용해 `다른 타입의 새로운 원시값을 생성하는 것`

암묵적 타입 강제 변환은 예측 불가능해 위험이 존재하지만 때로는 가독성을 높일 수 있음

중요한 것은 코드를 예측할 수 있어야 한다는 것이 중요 ❗️

<br />
<br />
<br />

# 9.2 암묵적 타입 변환

1 ) 문자열 변환

문자열 연결(+)에서 숫자나 불리언 등이 자동으로 문자열로 변환됨
```javascript
1 + "2"       // "12"
true + "입니다" // "true입니다"

0 + "" // "0"
NaN + "" // "NaN"

+'' // 0
+'1' // 1

+'string' // NaN
+true // 1
+false // 0

+null // 0

+Symbol() // TypeError
+{} // NaN
+[] // 0
+[10, 20] // NaN
+(function(){}) // NaN
```

2 ) 숫자 변환

산술 연산(-, *, /)에서는 피연산자가 숫자가 아닌 경우 숫자로 변환

```javascript
"5" - 2   // 3   ("5" → 5)
"10" * 2  // 20  ("10" → 10)
true * 3  // 3   (true → 1)
false / 2 // 0   (false → 0)
'1' > 0 // true  ('1' -> 1)
```

3 ) 불리언 변환

조건문에서 truthy / falsy 판별 시 자동 변환
```javascript
if ("hello") { console.log("실행됨"); }  // 빈 문자열("")만 false
if (0) { console.log("실행 안됨"); }     // 0, null, undefined, NaN, "" 은 false
```


> 자동 변환 규칙
> - 문자열 연결 → 문자열 변환
> - 산술 연산 → 숫자 변환
> - 조건문 평가 → 불리언 변환

<br />
<br />
<br />

# 9.3 명시적 타입 변환

1) 문자열(String) 변환

- String(), toString(), 문자열 연결(+ "")
```javascript
String(123);     // "123"
(123).toString(); // "123"
true + "";       // "true"
```

2) 숫자(Number) 변환

- Number(), parseInt(), parseFloat(), 단항 덧셈 연산자(+)

```javascript
Number("123");   // 123
parseInt("10px"); // 10
parseFloat("3.14"); // 3.14
+"42";            // 42
```

3) 불리언(Boolean) 변환

- Boolean(), 이중 부정 연산자(!!)

```javascript
Boolean("hello"); // true
Boolean("");      // false
!!123;            // true
!!0;              // false
```

>암묵적 변환보다 예측 가능하고 안전함

>협업 시 코드의 의도를 명확하게 드러낼 수 있음

>특히 조건문에서 !!value 같은 패턴을 자주 사용


<br />
<br />
<br />

# 9.4 단축 평가
논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있음
**논리합(||) 또는 논리곱(&&) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨❗️**

>논리 연산자(||, &&)의 특성을 이용해 불필요한 연산을 생략하는 것.
> 왼쪽 피연산자 값만으로 전체 표현식의 결과가 정해질 수 있으면, 오른쪽은 평가하지 않음


### OR 연산자 (||)

- 왼쪽 값이 truthy → 그대로 반환 (오른쪽은 무시)

- 왼쪽 값이 falsy → 오른쪽 값 반환

```javascript
console.log(true || "hello");   // true
console.log(false || "hello");  // "hello"
console.log("" || "default");   // "default" (빈 문자열은 falsy)
```

### AND 연산자 (&&)

- 왼쪽 값이 falsy → 그대로 반환 (오른쪽은 무시)

- 왼쪽 값이 truthy → 오른쪽 값 반환

```javascript
console.log(true && "hello");   // "hello"
console.log(false && "hello");  // false
console.log("hi" && 0);         // 0
```

### 유용한 패턴
**`객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때`**

단축 평가를 사용하면 에러를 발생시키지 않음❗️
```javascript
const elem = null;
const value = elem && elem.value; // null
```

**`기본값(Default value) 설정`**

사용자가 값을 주지 않았을 때 대체값을 넣고 싶을 때 유용함.
```javascript
let username = input || "Guest";
console.log(username); 
```
ES6의 디폴트 파라미터 문법이 있기 전에는 단축 평가를 많이 사용함.
```javascript
function greet(name) {
  let userName = name || "Anonymous";
  console.log("Hello, " + userName);
}
```

<br />



### 옵셔널 체이닝 ?.
ES11에 도입된 옵셔널 체이닝 연산자 **?.** 는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어감.
```javascript
let user = null;

console.log(user?.name); // undefined (에러 발생하지 않음)
```

```javascript
let user = {
  sayHi() { return "Hi!"; }
};

console.log(user.sayHi?.());   // "Hi!"
console.log(user.sayBye?.());  // undefined (에러 아님)
```

존재하지 않을 때 undefined를 반환할 뿐, **기본값을 주는 기능은 아님**
→ 기본값은 **Null 병합 연산자(??)** 와 함께 사용
```javascript
let user = null;
console.log(user?.name ?? "Guest"); // "Guest"
```


### 장점

#### TypeError 방지
- Cannot read property 'xxx' of undefined 같은 런타임 에러를 피할 수 있음

#### 가독성 향상
- obj && obj.prop && obj.prop.value 같은 복잡한 코드 대신 obj?.prop?.value로 간단히 표현

<br />

### null 병합 연산자 ??
좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고 그렇지 않으면 좌항의 피연산자를 반환. 변수에 기본값을 설정할 때 유리함.
```javascript
let username = null;
let displayName = username ?? "Guest";
console.log(displayName); // "Guest"
```
```javascript
let count = 0;
let result = count ?? 10;
console.log(result); // 0 (0은 null/undefined가 아니므로 그대로 유지)
```


#### ||와의 차이

- || (OR 연산자): falsy 값이면 오른쪽 반환

- ?? (null 병합): null 또는 undefined일 때만 오른쪽 반환

```javascript
let value1 = 0 || 100;   // 100 (0은 falsy)
let value2 = 0 ?? 100;   // 0   (0은 null/undefined 아님)

let value3 = "" || "hi"; // "hi" (빈 문자열은 falsy)
let value4 = "" ?? "hi"; // ""   (빈 문자열은 null/undefined 아님)
```