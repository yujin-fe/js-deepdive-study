# 9월 2주차(11장~15장)

날짜: 2025년 9월 14일

# 11장 원시 값과 객체의 비교

- 원시값 vs 참조값
    
    ### 1️⃣ 변수와 메모리
    
    모든 변수는 결국 **메모리 상의 어떤 위치를 가리키는 포인터 역할**
    
    - 원시값 변수도 사실 내부적으로는 **값이 저장된 메모리 위치를 가리키는 주소**를 갖고 있다.
    - 참조값 변수도 **객체가 있는 메모리 위치를 가리키는 주소**를 갖고 있다.
    
    차이는 **접근 방식과 레벨**입니다.
    
    ---
    
    ### 2️⃣ 원시값
    
    ```jsx
    let a = 10;
    ```
    
    - `a`라는 변수는 메모리 상에서 **10이라는 값이 저장된 위치**를 알고 있어요.
    - 우리가 `a`를 읽으면, 내부적으로 **주소를 통해 메모리에서 10을 꺼내오는 과정**이 일어나지만, 자바스크립트 입장에서는 그냥 “값 10”으로 보임.
    - 즉, **주소는 존재하지만 보이지 않고, 우리가 다루는 건 값 자체**
    
    ---
    
    ### 3️⃣ 참조값
    
    ```jsx
    let obj = { x: 1 };
    ```
    
    - `obj`는 **객체가 있는 메모리 위치**의 주소를 저장함
    - 우리가 `obj`를 읽으면, 실제로는 **주소를 따라가서 객체를 찾아가는 것**
    - 따라서 변수끼리 복사하면 주소를 공유하고, 한쪽에서 객체를 수정하면 다른 쪽에서도 바뀌는 것임
    
    ---
    
    ### 4️⃣ 핵심 정리
    
    | 구분 | 변수에 실제 저장된 것 | 우리가 접근할 때 보여지는 것 | 특징 |
    | --- | --- | --- | --- |
    | 원시값 | 값이 저장된 메모리 위치의 주소 | **값 자체** | 복사 시 값만 전달, 독립적 |
    | 참조값 | 객체가 있는 메모리 위치의 주소 | **주소가 가리키는 객체** | 복사 시 주소가 전달되어 같은 객체 공유 |
    - 요약하면, **원시값도 메모리 주소를 갖지만 우리가 접근할 때는 주소가 아닌 값 자체를 다룬다**
    - 반대로 **참조값은 주소를 통해 객체를 다루기 때문에 주소와 객체를 구분해서 이해해야 한다**
- 객체가 참조값인 이유
    
    메모리를 효율적으로 사용하기 위해, 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계 되어 있다. 
    
- 얕은 복사와 깊은 복사
    1. 단계에 대한 나눔
        1. 객체를 프로퍼티로 갖는 객체의 경우 얕은 복사는 한 단계 까지만 복사하는 것, 깊은 복사는 중접 객체 모두 복사하는 것
    2. 원시값과 참조값을 나눔
        1. 원시값을 복사하는 것은 깊은 복사, 객체에 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라함.
- 참조에 의한 전달 예시
    
    ```jsx
    var person1 = {
      name = "Lee"
    }
    
    var person2 = {
      name = "Lee"
    }
    
    console.log(person1 === person2); //false 주소가 다르다.
    console.log(person1.name === person2.name);//true 같은값
    ```
    

# 12장 함수

- 정의와 목적
    
    정의: 일련의 과정을 문으로 구현하고 코드 블록을 감싸서 하나의 실행 단위로 정의한 것
    
    사용목적: 코드의 재사용
    
- 타입
    
    함수는 객체 타입의 값 → 다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징
    
    ** 함수 리터럴에서 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.
    
- 함수 정의 방법
    - 함수 선언문
        - 함수 선언문은 표현식이 아닌 문이다.
        - 함수 리터럴과 형태가 동일하지만 함수 이름은 생략할 수 없다.
            - 형태가 동일하므로 문맥에 따라 리터럴로 해설될 수 있다.
                
                ```jsx
                function foo () { console.log('foo');}
                foo();
                
                (function bar() {console.log('bar')});
                bar(); //Reference error
                //피연산자로 취급되어 리터럴로 해석되었고,
                //함수 이름은 함수 몸체 내부에서만 참조 가능
                ```
                
    - 함수 표현식
        
        일급 객체: 값의 성질을 갖는 객체.
        
        - 함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야한다.
    - 선언문 vs 표현식
        - 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성시점이 다르다.
            - 함수 선언문: 런타임 이전에 함수 객체가 생성됨.
                
                →함수 호이스팅 됨.
                
            - 함수 표현식: 런타임에 할당무닝 실행되는 시점에 평가됨.
                
                →변수만 호이스팅 됨.
                
                →반드시 표현식 이후에 참조 또는 호출해야함.
                
    - Function 생성자 함수
    - 화살표 함수
- 순수함수와 비순수함수
    - 순수함수
        - 입력값만을 사용해 결과를 계산
        - 같은 입력이면 언제나 같은 결과
        - 외부 변수나 상태를 건드리지 않음
        - 일반적으로 하나 이상의 인수를 전달받음, 인수의 불변성 유지
        - **예시:**
            
            ```jsx
            function add(a, b) {
              return a + b;
            }
            ```
            
    - 비순수함수
        - 외부 상태(변수, 파일, 네트워크 등)에 의존하거나 변경
        - 같은 입력이라도 외부 상황에 따라 결과 달라짐
        - 부수효과(side effect) 발생
        - 매체변수로 객체를 전달받으면 비순수함수가 됨.
        - **예시:**
            
            ```jsx
            let count = 0;
            function increase() {
              count++;  // 외부 상태 변경
              return count;
            }
            ```
            
    
    순수 함수는 "입력 → 출력"만 바라보면 되고, 비순수 함수는 외부 세계까지 고려해야 함. 함수의 외부 상태의 변경을 지양하기 위해 순수함수를 사용하는 것이 좋음.
    

# 13장 스코프

스코프: 식별자가 유효한 범위, 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조 할 수있는 유효 범위가 결정된다.

** 식별자는 유일해야한다. → 다른 스코프 내에서는 같은 이름 사용가능하다.

- 스코프 체인
    
    자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.
    
- 렉시컬 스코프
    
    ```jsx
    var x = 1;
    
    function foo(){
    	var x = 10;
    	bar();
    }
    
    function bar(){
    	console.log(x);
    }
    
    foo();
    bar(); //1
    
    //자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 정의했는지에
    //따라 상위 스코프를 결정한다.(호출된 위치는 영향 x)
    ```
    

# 14장 전역 변수의 문제점

- 암묵적 결합
- 긴 생명 주기
    
    메모리 리소스 낭비
    
- 스코프 체인 상에서 종점에 존재
    - 누군가 스코프를 참조하고 있으면 스코프는 소멸되지 않고 생존하게 된다.
    - 전역 변수의 검색 속도가 제일 느리다.
- 네임스페이스 오염
    
    파일이 분리되어 있어도 하나의 전역 스코프를 공유하기에 예상치 못한 결과를 가져올 수 있다.
    
- 사용억제 방법
    - 즉시 실행 함수 → 실행하고 없애 버리기
    - 네임스페이스 객체 → 객체에 다 넣기
    - 모듈 패턴 → 클래스 모방, 모듈 만들기
    - ES6 모듈 → 모듈화하기

# 15장 let, const 키워드와 블록 레벨 스코프

- 호이스팅
    
    ```jsx
    let foo = 1;
    {
    	console.log(foo);//ReferenceError: Cannot access 'foo' before initialized
    	let foo = 2; 
    }
    //let 키워드로 선언한 변수도 호이스팅이 발생하므로 1이 출력되지 않고
    //에러가 발생함
    ```