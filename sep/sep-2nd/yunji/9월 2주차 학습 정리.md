# 11.1 원시 값

원시 타입 primitive type 의 값은 **변경 불가능한 값이다. → 읽기 전용 값 !**

- 숫자, 문자열, 불리언, null, undefined, …

## 값을 변경할 수 없다는 것은 무슨 의미 ?

- 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름 (재할당을 통해 값 교체 가능, 상수는 불가능)
- 값 : 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과 (변경 불가능)

```javascript
let num = 3 ;
```

→ num : 변수 

→ 3 : 값

```javascript
let score; // 변수 score 선언 
score = 80; // 변수 score에 원시값 80 할당
score = 90; // 원시값을 할당한 변수 score에 새로운 원시값 90 할당
```

![Alt text](image.png)
### 이때, 재할당 이전의 원시값(80)을 변경하는 것이 아닌

### 새로운 메모리 공간을 확보하고 재할당 원시값(90)을 저장한 후,

### 변수는 새로운 값을 가리킨다.

❌원시값이 변경 가능한 값이라면?❌

![Alt text](image-1.png)
➡️ 예상치 못한 변경이 발생할 수 있음

> 원시값을 저장하려면 먼저 확보해야 하는 메모리 공간의 크기를 결정해야 함.

> ⇒ 원시 타입 별로 메모리 공간의 크기가 미리 정해져있음

>Ex. 문자열 타입 2바이트(문자 1개), 숫자 타입 8바이트(고정)

# 값에 의한 전달

자바스크립트 용어는 아님

```javascript
let score = 80;
let copy = score;
```

변수(copy)에 원시값을 갖는 변수(score)를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값(80)이 복사되어 전달된다.

![Alt text](image-2.png)

**엄격하게는 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되는 것**

변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문!

```javascript
let score = 80;
let copy = score;
score = 100;

console.log(copy === score) // false
```

**두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값**이 되어 **어느 한 쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없음 !**

![Alt text](image-3.png)
---

# 11.2 객체

- 객체는 프로퍼티의 값과 개수가 정해져있지 않으며 동적으로 추가/삭제 가능 → 메모리의 크기 사전에 정할 수 없다
- 객체는 복합적인 자료구조이므로 원시값과 비교해서 관리가 복잡하고 비용이 많이든다.

### 자바스크립트 객체의 관리 방식

자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다.

(해시 테이블 : (Key, Value)로 데이터를 저장하는 자료구조 )

![Alt text](image-4.png)

클래스 기반 객체지향 프로그래밍 언어(자바, C++) : 

- 사전에 정의된 클래스를 기반으로 객체(인스턴스) 생성.
- 객체를 생성하기 이전에 이미 프로퍼티와 메서드가 정해져 있으며 그대로 객체 생성.
- 객체 생성 시점에는 값(데이터)이 채워지고, 메모리가 확보될 뿐

```java
// 클래스 정의 (설계도 작성)
class Student {
    String name;    // 프로퍼티(멤버 변수, 속성)
    int age;        // 프로퍼티

    void study() {  // 메서드(멤버 함수, 기능)
        System.out.println(name + " 공부 중...");
    }
}

Student s = new Student(); // 참조 변수 s를 스택(Stack)에 만들고 힙에 있는 Student 객체의 주소를 가리킴
```

자바스크립트는 클래스 없이 객체 생성 가능. 객체 생성 이후 동적으로 프로퍼티를 삭제하거나 추가할 수 있음. 

**→ V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 히든 클래스라는 방식을 사용해 성능 보장.** 

히든 클래스는 자바와 같이 고정된 객체 레이아웃(클래스)과 유사하게 동작함. 

https://jaehyeon48.github.io/javascript/hidden-class-ic/

## 변경 가능한 값

객체(참조) 타입의 값, 즉 객체는 변경 가능한 값임. 

```jsx
let person = {
	name: 'Lee'
};
```

객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있음. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체임.

![Alt text](image-5.png)

`person`에 접근하면 `{ name: 'Lee' }` 가 저장된 메모리 공간의 주소에 접근

```java
let person = {
	name: 'Lee'
};

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 생성
person.address = 'Seoul';
```

객체를 할당한 변수는 재할당 없이 객체를 직접 변경 가능

→ 재할당 없이 프로퍼티를 동적으로 추가할 수 있고 프로퍼티 값을 갱신할 수 있고, 프로퍼티 자체를 삭제할 수도 있음. 

![스크린샷 2025-09-13 오후 12.21.22.png](attachment:57d11bfa-eaf2-456d-8c6a-15e4070008a6:스크린샷_2025-09-13_오후_12.21.22.png)

객체를 할당한 변수의 참조값은 변하지 않음

객체는 크기가 매우 클 수도 있기 때문에 **원시값처럼 이전 값을 복사해서 새로 생성하면 생성비용 많이 듦.** 

### ⇒ 객체는 변경 가능한 값으로 설계됨.

부작용 :  여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것

### 얕은 복사shallow copy와 깊은 복사 deep copy

![Alt text](image-6.png)

- 얕은 복사 : 객체에 중첩된 객체의 참조 값을 복사 (한 단계 까지만 복사)
- 깊은 복사 : 객체에 중첩되어 있는 객체까지 모두 복사해서 원시값처럼 완전한 복사본 생성 (중첩 단계까지 모두 복사)

### 얕은 복사

- 객체의 **최상위 프로퍼티 값만 복사**하는 방식.
- 프로퍼티가 **원시값(숫자, 문자열, 불리언 등)**이면 값 자체가 복사됨.
- 프로퍼티가 **객체(배열, 객체, 함수 등)**라면 **참조(메모리 주소)**만 복사됨.
- 즉, 복사본과 원본이 내부 객체를 **공유**하게 됨.

```javascript
const obj1 = { 
  name: "윤지", 
  info: { age: 20 } 
};

// 얕은 복사
const obj2 = { ...obj1 };

obj2.name = "철수";         // 원시값: 복사본만 변경
obj2.info.age = 25;         // 참조 공유: 원본도 함께 변경

console.log(obj1.name);     // "윤지"  (독립적)
console.log(obj1.info.age); // 25      (같이 바뀜)
```

### 깊은 복사

- 객체의 **모든 계층(내부 객체 포함)**을 새로 복사하는 방식.
- 원본과 복사본이 **완전히 독립적**임.

```javascript
const obj1 = { name: "윤지", info: { age: 20 } };

const obj2 = structuredClone(obj1);

obj2.info.age = 25;

console.log(obj2.info.age); // 25
console.log(obj1.info.age); // 20 (영향 없음)
```

### 참조에 의한 전달

```javascript
let person = {
	name: 'Lee'
};

let copy = person;
```

객체를 가리키는 변수 person 을 다른 변수 copy 에 할당하면 원본의 참조값이 복사되어 전달됨. 이를 참조에 의한 전달이라 함. 

![Alt text](image-7.png)

**person과 copy가 저장된 메모리 주소는 다르지만** **동일한 참조값(객체가 저장된 주소값)**을 가짐.

⇒ 원본 person 과 사본 copy 가 동일한 객체를 가리킴

⇒ 두 개의 식별자가 하나의 객체 공유

**⇒ 둘 중 어느 한 쪽에서 객체를 변경하면 서로 영향을 주고 받음**

“값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 **메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일**( 변수에 저장된 값이 원시 값이냐 참조 값(주소)이냐의 차이 )

⇒ 자바스크립트는 “참조에 의한 전달”은 존재 x, 값에 의한 전달만 존재한다고 말할 수 있다. 

변수에 저장된 값이 원시 값이냐 참조 값(주소)이냐의 차이 구별하기 위해 “값에 의한 전달”과 “참조에 의한 전달”로 구분하여 부르기도 하지만 자바스크립트에는 포인터가 존재하지 않으므로 엄밀하게 “참조에 의한 전달”과 의미가 정확히 일치하지 않음. 

## 포인터란?

- **메모리 주소를 저장하는 변수**
- 일반 변수는 값을 저장하지만, 포인터는 그 값이 들어 있는 **메모리 위치(주소)**를 저장함.

---

```cpp
int a = 10;     // 일반 변수
int* p = &a;    // 포인터: a의 주소를 저장
```

- `&a` → 변수 `a`의 주소
- `int* p` → "int형 변수를 가리키는 포인터"

---

## 포인터 사용 (역참조)

```cpp
cout << a << endl;   // 10
cout << p << endl;   // a의 주소
cout << *p << endl;  // p가 가리키는 값 = 10
```

- `p` : 포인터가 가리키는 **실제 값**에 접근 (역참조, dereference)

**참조에 의한 전달은 함수가 원본 데이터를 직접 수정할 수 있도록, 변수의 주소(참조)를 넘기는 방식.**