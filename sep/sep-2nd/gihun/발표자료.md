# p.217 const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다.

```
const person = {
    name: 'seon'
};

person.name = 'kim'

console,log(person) // { name: 'kim' }

```

+ 이유 : 객체는 참조 타입 
   
+ const는 변수의 참조값을 고정시킬 뿐, 객체의 내부 구조를 고정시키는 것은 아님.



### const는 변수 재할당을 막을 뿐 객체의 불변성을 보장하지않음

+ 밑의 예시는 객체를 못변하게 만들고 싶을떄 사용하는 코드(Object.freeze) 

```
const person = Object.freeze({
  name: "Alice",
  age: 25
});

person.age = 30; // 무시됨 (strict mode면 에러 발생 가능)
console.log(person.age); // 25
```

###  정리 

+ "const는 값을 완전히 고정시키는 게 아니라, 참조만 고정시킵니다. 객체나 배열을 다룰 때 이 차이를 이해하는 것이 매우 중요"


## 추가 사항 참조

```
const person = { name: "Alice" };
```

+ 참조값= 메모리주소값 위 자료에서는 편의상 A 라 지정

+ person 변수 에는   { name: "Alice" }; 객체가 직접들어있는게 아님

+  { name: "Alice" }; 가 저장된 A(메모리 주소) 가 들어있음

### 참조 고정

위 코드처럼 선언시 :

+ person 변수는 항상 A주소 를 가리키도록 고정 

+ 다른 주소로 변경은 불가능

### 그러나! A 주소 안에 있는 내용( bite )는 변경가능!

```
const person = {
    name: 'seon'
};

person.name = 'kim'

console,log(person) // { name: 'kim' }
```

+ person 변수는 계속  A주소를 가리키고 있음

+ A주소 안의 객체의 name 프로퍼티만 바뀜(메모리 안에 저장된 bite 값은 변경가능)

## 정리

+ const사용시 변수에 메모리 주소(참조)는 바꿀수 없음

+ 메모리 주소(참조) 안에 bite값은 변경가능

+ 메모리 주소(참조)값과 메모리주소(참조)값 안에 bite의 차이를 이해하기~